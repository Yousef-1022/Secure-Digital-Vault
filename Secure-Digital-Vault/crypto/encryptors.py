from custom_exceptions.classes_exceptions import FileError, EncryptionFailure
from file_handle.file_io import append_bytes_into_file, stabilize_after_failed_append
from utils.extractors import get_icon_from_file

from utils.constants import CHUNK_LIMIT
from utils.helpers import get_file_size
from crypto.utils import generate_aes_key

from threads.mutable_boolean import MutableBoolean

from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad

def encrypt_bytes(data : bytes, password : str, key : bytes = None, iv : bytes = None) -> bytes:
    """
    Encrypts bytes using AES encryption in CBC mode. Adds salt+iv to the beginning of the encrypted bytes if not key and iv

    Args:
        data (bytes): The data to encrypt.
        password (str): The password used for encryption.
        key (str, optional): Key generated by generate_aes_key , useful for large file encryption
        iv (bytes, optional): The initialization vector for AES

    Returns:
        bytes: The encrypted data.
    """
    res = None
    try:
        # Large File Scenario
        if key and iv:
            cipher = AES.new(key, AES.MODE_CBC, iv)
            ct_bytes = cipher.encrypt(pad(data, AES.block_size))
            res = ct_bytes
        # Small File Scenario
        else:
            iv = get_random_bytes(16)
            salt = get_random_bytes(16)
            key = generate_aes_key(password=password.encode(), salt=salt, key_length=32)
            cipher = AES.new(key, AES.MODE_CBC, iv)
            ct_bytes = cipher.encrypt(pad(data, AES.block_size))
            res = salt + iv + ct_bytes
    except Exception as e:
        raise EncryptionFailure(e)
    return res

def encrypt_header(password : str , header : bytes) -> bytes:
    """Encrypts the header with AES

    Args:
        password (str): Password.
        header (bytes): Serialized header.

    Info:
        Potential failure in Encryption could be raised, but as the header is always a valid json, this is not ought to happen.

    Returns:
        bytes: Encrypted header.
    """
    result = encrypt_bytes(header, password)
    return result

def encrypt_footer(password : str , footer : bytes) -> bytes:
    """Encrypts the footer with AES

    Args:
        password (str): Password.
        header (bytes): Serialized header.

    Info:
        Potential failure in Encryption could be raised, but as the footer is always a valid json, this is not ought to happen.

    Returns:
        bytes: Encrypted footer.
    """
    result = encrypt_bytes(footer, password)
    return result

def get_file_and_encrypt_and_add_to_vault(password : str, file_path : str, vault_path : str, continue_running : MutableBoolean) -> list:
    """Gets the file as bytes, encrypts during reading to avoid memory overhead, and adds it to the vault on disk.
    Also, adds the icon. Chunk size while getting file and encrypting chunk is CHUNK_LIMIT

    Args:
        password (str): Password of the vault.
        file_path (str): File location.
        vault_path (str): Vault path
        keep_running (MutableBoolean): Boolean to abort process

    Raises:
        FileError, EncryptionFailure incase it was not able to handle failure

    Returns:
        list: [0] index is: file_loc_start, [1] index is: file_loc_end, [2] index is: encrypted_file_size,
        [3] is: icon_loc_start, [4] is: icon_loc_end.
        If less values than 5 are returned, then an error has occured.
        4 values indicate that the addition of the file itself was fine, but last value is the error.
    """
    if not continue_running.get_value():
        return []
    ans = []
    encrypted_file_size = 0
    added_bytes = 0
    chunk_size = CHUNK_LIMIT

    res = get_file_size(vault_path)
    if res <= 0:
        raise FileError(f"Vault: {vault_path} at initial stage has size of '{res}'!")
    init_vault_size = res
    loc_start = init_vault_size

    res = get_file_size(file_path)
    if res <= 0:
        raise FileError(f"File: {file_path} at initial stage has size of '{res}'!")
    file_size = res

    with open(file_path, "rb") as file:

        # Encrypting a large file, must add salt_iv first, then add the encrypted data
        salt = get_random_bytes(16)
        iv = get_random_bytes(16)
        salt_iv = salt + iv
        key = generate_aes_key(password=password.encode(), salt=salt, key_length=32)
        encrypted_chunk = salt_iv

        # Chunk reading
        while continue_running.get_value():
            chunk = None
            chunk = file.read(chunk_size)
            if not chunk:
                break

            # Encrypt chunk
            try:
                encrypted_chunk += encrypt_bytes(data=chunk, password=password, key=key, iv=iv)
            except EncryptionFailure as e:
                continue_running.set_value(False)
                error_str = stabilize_after_failed_append(vault_path, e.message, init_vault_size, added_bytes)
                raise EncryptionFailure(f"Removed added bytes, but failure happened during encryption: {error_str}")

            encrypted_file_size += len(encrypted_chunk)
            if not continue_running.get_value():
                break

            # Append
            res = append_bytes_into_file(file_path=vault_path, the_bytes=encrypted_chunk)

            if not res[0] or not continue_running.get_value():
                continue_running.set_value(False)
                error_str = stabilize_after_failed_append(vault_path, res[1], res[2], added_bytes)
                raise FileError(f"Removed added bytes, but failure happened after appending bytes: {error_str}")

            added_bytes += encrypted_file_size
            # Chunk needs a restart after adding salt_iv
            encrypted_chunk = b''
            # Quit once reached the end of file
            if file.tell() >= file_size:
                break
        # Incase Loop broke because of abort
        if not continue_running.get_value():
            error_str = stabilize_after_failed_append(vault_path, "appended:0", init_vault_size, added_bytes)
            raise FileError(f"{error_str}. Expected to add {file_size} + padding")

    res = get_file_size(vault_path)
    new_vault_size = res

    loc_end = new_vault_size
    ans.append(loc_start)
    ans.append(loc_end)
    ans.append(encrypted_file_size)
    # From this point onward its fine to add file into vault because the answer list has 3 values at least

    if not continue_running.get_value():
        ans.append("Continue running is turned off!")
        return ans

    file_icon = get_icon_from_file(file_path)

    icon_start = loc_end
    res = append_bytes_into_file(file_path=vault_path, the_bytes=file_icon)
    if not res[0]:
        prev_error = stabilize_after_failed_append(vault_path, res[1], res[2], res[3]-res[2])
        prev_error += ", the file has no icon bytes"
        ans.append(prev_error)
        return ans

    # Icon tuple + EncryptedFileSize
    res = get_file_size(vault_path)
    icon_end = res

    ans.append(icon_start)
    ans.append(icon_end)
    return ans
