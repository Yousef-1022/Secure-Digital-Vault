from utils.constants import *
from utils.parsers import parse_json_safely
from utils.id_gen import gen_id
from utils.serialization import serialize_dict
from utils.helpers import count_digits

from custom_exceptions.classes_exceptions import JsonWithInvalidData, MissingKeyInJson

from crypto.encryptors import encrypt_password_storage, encrypt_header
from crypto.decryptors import decrypt_password_storage
from crypto.utils import xor_magic

from file_handle.file_io import override_bytes_in_file, add_magic_into_header


class Vault:
    def __init__(self, password : str, vault_path : str):
        self.__header = {}
        self.__map = {}
        self.__footer = {}
        self.__vault_path = vault_path
        self.__password = encrypt_password_storage(password)

    # Getters, Setters and Loaders
    def get_header(self) -> dict:
        return self.__header

    def set_header(self, header:dict):
        """Sets the header

        Args:
            header (dict): header to set
        """
        self.__header = header
        self.__map = self.__header["map"]

    def refresh_header(self, return_it : bool = False) -> bytes:
        """Refreshes the header size and has an optional value to return the header.

        Args:
            return_it (bool) optional: choice to to return the header or not

        Returns:
            bytes: serialized new header, but not encrypted
        """
        # Other data is updated in real time, we only need to update the size.
        old_header_serialized = serialize_dict(self.__header)
        old_header_len = self.__header["vault"]["header_size"]
        old_digits = count_digits(old_header_len)
        new_header_len = len(old_header_serialized)
        new_digits = count_digits(new_header_len)
        self.__header["vault"]["header_size"] = new_header_len + (new_digits - old_digits)
        new_header_serialized = serialize_dict(self.__header)
        if return_it:
            return new_header_serialized
        return None

    def get_password(self) -> str:
        return decrypt_password_storage(self.__password)

    def set_password(self, password : str) -> None:
        self.__password = encrypt_password_storage(password)

    def get_map(self) -> dict:
        return self.__map

    def set_map(self, map:dict):
        """Sets the map

        Args:
            map (dict): map to set
        """
        self.__map = map

    def get_footer(self) -> dict:
        return self.__footer

    def set_footer(self, footer:dict):
        """Sets the footers

        Args:
            footer (dict): footer to set
        """
        self.__footer = footer

    def get_vault_path(self) -> str:
        return self.__vault_path

    def get_vault_size(self) -> int:
        return self.__header["vault"]["header_size"]

    def determine_if_dir_path_is_valid(self, dir_names : list, level : int = 0) -> tuple[bool,int]:
        """Based on the name of a dir, tries to determine whether it is a valid path,
        this function works in harmony with: parse_directory_string

        Args:
            dir_names (list): A list containing all the dir names, e.g, [path,to,somewhere] generated by parse_directory_string
            level (int): current level of directory, e.g, /path/to/somewhere path is 1 , to is 2 , somewhere is 3

        Returns:
            tuple: first part if valid, second part showing the last level
        """
        data_dict = self.get_map()["directories"]
        length = len(dir_names)
        if length < 1:
            return True,level
        elif length == 1 and dir_names[0] == "/":
            return True,0
        else:
            for some_dir in data_dict.values():
                if dir_names[0] == some_dir["name"] and some_dir["path"] == level:
                    return self.determine_if_dir_path_is_valid(dir_names[1:], some_dir["id"])
        return False,level

    @staticmethod
    def determine_directory_path(path_id: int, data_dict: dict, current_name: str = None) -> str:
        """Based on the path id , returns the full path name representing the id, e.g: for 2: 'id2 = matter , id1 = splendid' will return: /splendid/matter/
            This is done recursively, and the given data_dict must be valid. (This is checked beforehand)
        Args:
            path_id (int): path id of the directory
            data_dict (dict): dict containing all the dictionaries

        Returns:
            str: Name of the directory, "/" If path <= 0
        """
        if path_id <= 0:
            if current_name is None:
                return "/"
            return f"/{current_name}/"

        if str(path_id) not in data_dict:
            if current_name is None:
                return "/"
            return f"/{current_name}/"

        parent_name = data_dict[str(path_id)]["name"]

        if current_name is not None:
            parent_name += f"/{current_name}"

        parent_id = data_dict[str(path_id)]["path"]
        return Vault.determine_directory_path(parent_id, data_dict, parent_name)

    def __insert_file_id(self, file_id : int):
        self.__map["file_ids"].append(file_id)

    def insert_file(self, file_dict : dict):
        self.__map["files"][str(file_dict["id"])] = file_dict
        size = file_dict["size"]
        self.__header["vault"]["file_size"] += size
        self.__header["vault"]["amount_of_files"] += 1

    def insert_file_id_into_folder(self, folder_id : int , file_id : int):
        if folder_id > 0 and file_id > 0:
            self.__map["directories"][str(folder_id)]["files"].append(file_id)

    def __insert_folder_id(self, folder_id : int):
        self.__map["directory_ids"].append(folder_id)

    def insert_folder(self, folder_dict : dict):
        self.__map["directories"][str(folder_dict["id"])] = folder_dict

    def __insert_voice_note_id(self, voice_note_id : int):
        self.__map["voice_note_ids"].append(voice_note_id)

    def insert_voice_note(self, voice_note_dict : dict):
        self.__map["voice_notes"][str(voice_note_dict["id"])] = voice_note_dict
        icon_size = voice_note_dict["loc_end"] - voice_note_dict["loc_start"]
        self.__header["vault"]["file_size"] += icon_size
        self.__header["vault"]["amount_of_files"] += 1 # Counts as a File

    # Header Validators
    def validate_header(self, full_header:bytes) -> dict:
        """Validates the full header represented in bytes

        Args:
            full_header (bytes): Full header representation in bytes

        Raises:
            JsonWithInvalidData: Incase the header contains invalid data
            MissingKeyInJson: Incase there is a missing key within the inner values of the header

        Returns:
            dict: the header without magic bytes
        """
        header = parse_json_safely(full_header)
        if("error" in header):
            raise JsonWithInvalidData(str(header["error"]))
        if (self.__validate_header_keys(header)): # Can raise MissingKeyInJson or JsonWithInvalidData
            return header
        raise JsonWithInvalidData(f"JSON has incorrect magic bytes. Obj len: {len(full_header)}, Obj: {str(full_header)}")

    def __validate_header_keys(self, header: dict) -> bool:
        """Validates the full header of the vault. (vault + map)

        Args:
            header (dict): the whole header containing all keys

        Raises:
            MissingKeyInJson: Indicating that a key does not exist
            JsonWithInvalidData: Indicating that a value is of incorrect type

        Returns:
            bool: Upon success
        """
        for key in ["vault", "map"]:
            if key not in header:
                raise MissingKeyInJson(f"Key '{key}' is missing from the Vault main header.")

        self.__validate_vault_keys(header["vault"])
        self.__validate_map_keys(header["map"])

        return True

    def __validate_vault_keys(self, vault : dict) -> None:
        """Checks if the key 'vault' contains valid keys.

        Args:
            vault (dict): the dict of the the 'vault' key
        """
        for key in VAULT_KEYS:
            if key not in vault:
                raise MissingKeyInJson(f"Key '{key}' is missing from the 'vault' header.")
            if key == "vault_name" or key == "vault_extension":
                try:
                    if not isinstance(vault[key], str):
                        raise JsonWithInvalidData(f"Value for key '{key}' must be a string but '{vault[key]}' is of type: {type(vault[key])}.")
                except KeyError:
                        raise MissingKeyInJson(f"Key '{key}' does not exist in the 'vault' dict!")
            elif key == "is_vault_encrypted":
                try:
                    if not isinstance(vault[key], bool):
                        raise JsonWithInvalidData(f"Value for key 'is_vault_encrypted' must be a boolean but '{vault[key]}' is of type: {type(vault[key])}.")
                except KeyError:
                    raise MissingKeyInJson("Key 'is_vault_encrypted' does not exist in the 'vault' dict!")
            else:
                try:
                    if not isinstance(vault[key], int):
                        raise JsonWithInvalidData(f"Value for key '{key}' must be an integer but '{vault[key]}' is of type: {type(vault[key])}.")
                except KeyError:
                    raise MissingKeyInJson(f"Key '{key}' does not exist in the 'vault' dict!")

    def __validate_map_keys(self, map : dict) -> None:
        """Checks if the key 'map' contains valid keys, but does not check the correctness of files, directories, voice_notes

        Args:
            map (dict): the dict of the the 'map' key
        """
        for key in MAP_KEYS:
            if key not in map:
                raise MissingKeyInJson(f"Key '{key}' is missing from the 'map' dict")
            # file_ids , directory_ids, voice_note_ids
            if key[-3:] == "ids":
                try:
                    if not isinstance(map[key], list):
                        raise JsonWithInvalidData(f"Value for key '{key}' must be a list but '{map[key]}' is of type: {type(map[key])}.")
                    else:
                        for value in map[key]:
                            if not isinstance(value, int):
                                raise JsonWithInvalidData(f"The'{key}' must contain a list of integers but '{value}' is of type: {type(value)}.")
                except KeyError:
                        raise MissingKeyInJson(f"Key '{key}' does not exist in the 'map' dict!")
            # files, directories, voice_notes
            else:
                try:
                    if not isinstance(map[key], dict):
                        raise JsonWithInvalidData(f"Value for key '{key}' must be a dict but '{map[key]}' is of type: {type(map[key])}.")
                    else:
                        for value in map[key]:
                            if not isinstance(value, str):
                                raise JsonWithInvalidData(f"The '{key}' key must be a str (id) only, but '{value}' is of type: {type(value)}.")
                        for value in map[key].values():
                            if not isinstance(value, dict):
                                raise JsonWithInvalidData(f"The '{key}' key must be of type dict only, but '{value}' is of type: {type(value)}.")
                except KeyError:
                    raise MissingKeyInJson(f"Key '{key}' does not exist in the 'map' dict!")

    # Footer Validators _ TODO
    def validate_footer(self, full_footer:bytes) -> dict:
        """Validates the full footer represented in bytes

        Args:
            full_footer (bytes): Full footer representation in bytes

        Raises:
            JsonWithInvalidData: Incase the footer contains invalid data
            MissingKeyInJson: Incase there is a missing key within the inner values of the footer

        Returns:
            dict: the footer without magic bytes
        """
        footer = parse_json_safely(full_footer)
        if("error" in footer):
            raise JsonWithInvalidData(str(footer))
        if (self.__check_footer_keys(footer)): # Can raise MissingKeyInJson
            return footer
        raise JsonWithInvalidData(f"JSON has incorrect magic bytes. Obj len: {len(full_footer)}, Obj: {str(full_footer)}")

    def __check_footer_keys(self, footer:dict) -> bool:
        for key in ["error_log", "session_log"]:
            if key not in footer:
                raise MissingKeyInJson(f"Key: {key} is missing from the Vault main Footer.")
            if "loc_start" not in footer[key]:
                raise MissingKeyInJson(f"Key: {key} is missing from the Vault Footer.")
            if "loc_end" not in footer[key]:
                raise MissingKeyInJson(f"Key: {key} is missing from the Vault Footer.")
        return True

    def update_vault_file(self):
        """Updates the vault with the newly encrypted header, and updates the disk.
        """
        header = self.refresh_header(return_it=True)
        header = encrypt_header(self.get_password(), header)
        header = add_magic_into_header(header, start_only=True, pad_only=True, end_only=False)
        override_bytes_in_file(file_path=self.__vault_path, given_bytes=header, byte_loss=0, chunk_size=65536, at_location=0)

    def generate_id(self, type : str) -> int:
        """Generates a new ID for either a new file or a new folder or a new voice

        Args:
            type (str): F for File, D for Folder, V for VoiceNote

        Returns:
            int: The new id

        Throws: ClashedIdException
        """
        the_id = -1
        if type == "F":
            the_id = gen_id(self.__map["file_ids"] , "file_ids")
            self.__insert_file_id(the_id)
        elif type == "D":
            the_id = gen_id(self.__map["directory_ids"], "directory_ids")
            self.__insert_folder_id(the_id)
        elif type == "V":
            the_id = gen_id(self.__map["voice_note_ids"], "voice_note_ids")
            self.__insert_voice_note_id(the_id)
        return the_id
